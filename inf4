#! /bin/bash

# program at end of file. search #MAIN


: <<=cut
=pod

=head1  NAME

  inf4 - Communicate with a Fedora 4 server

=head1 USAGE

  inf4 [-b|--base=I<base>] [-x|--prefix=I<prefix>] [-r|--no-rc] \
	[-n|--dry-run] [-d|--dir] [-i|--interactive] [-p|--print] \
	I<cmd> [cmd-options] 

	where <cmd> = config|patch|put|mkdir|ls|delete|GET|HEAD|OPTIONS|url

=cut
	
: <<=cut

=pod

=head1 OPTIONS

=over 4	

=item B<-b|--base=I<INF4_BASE>>
 set the Fedora4 URL

=item B<-x |--prefix=> I<prefix>>
Add a new prefix for ttl, using prefix:url  format 

=item B<-r|--no-rc>
Do not read from or write to rc file.

=item B<-n|--dry-run>
Show what you would do do not really do it

=item B<-d|--dir>
Set URL (wrt. INF4_BASE) for this operation only

=item B<-i|--interactive>
Use interactive mode

=item B<-p|--print>
Adjust httpie --print= argument

=item B<--session>
Add httpie --session= argument

=back
=cut

function main.cmd () {
    cmd=$1
    shift;
    
    case $cmd in
	cd | pwd | pushd | popd ) # Directory Commands
	    $cmd $@;
	    ;;
	touch | ls | delete | mkdir | put | config | patch | prefix)
	    $cmd $@;
	    ;;
	GET | HEAD | OPTIONS | url )	# http requests
	    $cmd $@;
	    ;;

	*)
	    echo  "$cmd not found";
	    ;;
    esac
}

: <<=cut
=pod

=head1 CMD

=cut
function main.options() {
    declare -A default_prefix=( 
	[acl]="http://www.w3.org/ns/auth/acl#"
	[dc]="http://purl.org/dc/elements/1.1/"
	[dct]="http://purl.org/dc/terms/"
	[pcdm]="http://pcdm.org/models#"
	[ebucore]="http://www.ebu.ch/metadata/ontologies/ebucore/ebucore#"
	[fast]="http://id.worldcat.org/fast/"
	[fedora]="http://fedora.info/definitions/v4/repository#"
	[foaf]="http://xmlns.com/foaf/0.1/"
	[ldp]="http://www.w3.org/ns/ldp#"
	[locname]="http://id.loc.gov/authorities/names/"
	[rdfs]="http://www.w3.org/2000/01/rdf-schema#"
	[webac]="http://fedora.info/definitions/v4/webac#"
	[user]="http://cas.ucdavis.edu/user/"
	[group]="http://cas.ucdavis.edu/group/"
	[w]="http://library.ucdavis.edu/wine-ontology#"
	[wdt]="http://www.wikidata.org/prop/direct/"
    )


    for i in  ${!default_prefix[*]}; do
	PREFIX[$i]=${default_prefix[$i]};
    done

    OPTS=`getopt -o h:rx:nd:ip:s: --long base:,no-rc,prefix:,dry-run,dir:,interactive,print:,session: -n 'inf4' -- "$@"` 

    if [ $? != 0 ] ; then echo "Bad Command Options." >&2 ; exit 1 ; fi

    eval set -- "$OPTS"

    PUSHED=0
    noop=0
    INTERACTIVE=0
    dirz=()				# For Pushd popd
    RC=1
    print=hb

    # Check for no-rc first
    case "$OPTS" in
	*"-r "*) RC=0;;
	*"--no-rc "*) RC=0 ;;
    esac
    
    if (( $RC )); then
	config.readrc;
    fi;
    CWD=$(config.cwd);

    while true; do
	case $1 in
	    -b | --base) INF4_BASE=$2;  shift 2;;
	    -x | --prefix) prefix $2 > /dev/null; shift 2 ;;
	    -r | --no-rc) rc=0; shift ;; 
	    -n | --dry-run) noop=1; shift ;;
	    -d | --dir)
		PUSHED=1
		dirz=("$2" "${dirz[@]}"); # Simple pushd
		shift 2;
		;;
	    -i | --interactive) INTERACTIVE=1; shift;;
	    -p | --print) print=$2; shift 2;;
	    -s | --session) session=$2; shift 2;;
	    -- ) shift; break;;
	    *) shift; break;
	esac
    done

    # Now set the CMD String
    CMD="$*"
}


# Configuration commands
function config.files () {
    for f in ~/.inf4rc .inf4rc; do
	if [[ -f $f ]]; then echo $f; fi;
    done
}

function config.readrc () {
    for f in `config.files`; do
	if [[ -f $f ]]; then
	    . $f
	fi
    done
}

function config.writerc () {
    if [[ ! -z $1 ]]; then
	file=$1
    elif [[ -f .inf4rc ]] ; then
	file=.inf4rc
    else
	file=~/.inf4rc;
    fi;
    
    echo "INF4_BASE="$INF4_BASE > $file
    for k in  ${!prefix[*]}; do
	if [[ -z ${default_prefix[$k]} ]] ; then 
	    echo "prefix[$k]=${prefix[$k]}" >> $file;
	fi
    done
    echo '#DIRZ' >> $file
    # for k in  ${!dirz[*]}; do
    # 	echo "dirz[$k]=${dirz[$k]}" >> $file;
    # 	echo "dirz[$k]=${dirz[$k]}" > file;
    # done
    echo 'dirz=('${dirz[*]}')' >> $file;
}

function config.host () {
    echo $(echo $INF4_BASE | cut -d/ -f1-3)
}

function config.cwd () {
    echo /$(echo $INF4_BASE | cut -d/ -f4-)
}


: <<=cut
=pod

=head2 config

=head3 USAGE

inf4 [inf4options] -- config print|init

=head4 print

Prints the current configuration files in use.

=head4 init

Writes or overwrites the configuration file <./.inf4rc>. And options passed to the
inf4 command are included, For example

inf4 --base=https://foo.com/fcrepo/rest/bar \
     --prefix=baz:https://baz.org/schema config

Will write a new configuration file with the base and prefix set.

=cut
function config() {
    cmd=$1;
    case $cmd in
	 print)
	     for f in `config.files`; do
		 echo "# $f"
		 cat $f;
	     done
	     ;;
	 init)
	     touch .inf4rc;
	     config.writerc;
	     config.writerc /dev/stdout;
	     ;;	     
	 *) (>&2 echo "Bad config cmd $cmd")
    
    esac;
}

# Location Commands
# Change directory -
# if a user sez 'inf4 -d foo cd'  we take that to mean 'inf4 cd foo'
# and 'inf4 -d foo cd bar' is equal to 'inf4 cd foo; inf4 cd bar'
function cd () {    
    if (( $PUSHED )); then
	if [[ ${dirz[0]} == /* ]]; then
	    CWD=${dirz[0]};
	else
	    CWD=$(pwd)
	fi
	dirz=();
    fi
    if [[ ! -z $1 ]] ; then
	if [[ $1 == /* ]] ; then
	    CWD=$1;
	else
	    CWD=$(readlink -m $(pwd)/$1)
	fi
    fi
    # Reset to your base ${CWD}
    dirz=();
    INF4_BASE=$(config.host)${CWD}
#    pwd;
}

function pushd () {
    if (( $PUSHED )); then
	if [[ -z $1 ]]; then
	    PUSHED=0;
	else
	    p=${dirz[0]}
	    popd > /dev/null
	    dirz=("${p}/$1" "${dirz[@]}")
	fi
    else
	if [[ ! -z $1 ]] ; then
	    dirz=("$1" "${dirz[@]}");
	fi;
    fi;
#    pwd;
}

function popd () {
    dirz=("${dirz[@]:1}")
#    pwd;
}

function pwd () {
    pwd=
    dir=${dirz[0]}
    if [[ -z $dir ]]; then
	pwd=${CWD};
    else
	if [[ $dir == /* ]]; then
	    pwd=${dir}
	else
	    pwd=$(readlink -m ${CWD}/${dir})
	fi
    fi
    if [[ ! -z $1 ]]; then 	# Can add to pwd for relative links
	if [[ $1 == /* ]]; then
	    pwd=$1
	else
	    pwd=$(readlink -m ${pwd}/${1})
	fi	
    fi
    echo ${pwd}
}

function url () {
    echo $(config.host)$(pwd) ;
} 

function _http () {
    args='';
    if [[ -n $session ]]; then
	args+="--session=$session"
    fi
	http --print=$print $args $@
}

# Direct HTTP Requests
function GET () {
    _http GET $(url)
}

function OPTIONS () {
    _http OPTIONS $(url)
}

function HEAD () {
    _http HEAD $(url)
}

# INF4 write information
function prefix () {
    if [[ ! -z $1 ]]; then
	pre=${1%%:*};
	url=${1#*:};
	if [[ -z $url ]]; then
	    unset PREFIX[$pre]
	else
	    PREFIX[$pre]=$url;
	fi
    fi
    for i in  ${!PREFIX[*]}; do echo "@prefix $i: <${PREFIX[$i]}> . " ; done   
}

function prefix.sp () {
    for i in ${!PREFIX[*]}; do echo "PREFIX $i: <${PREFIX[$i]}>" ; done   
}

function ldp_direct () {
    echo '<> a ldp:DirectContainer, pcdm:Object ;
  ldp:hasMemberRelation pcdm:'$1' ;
  ldp:membershipResource <'$(pwd $2)'> .'
}

function patch () {
    insert='';
    while IFS= read -r line || [[ -n "$line" ]]; do
#	line=${line%?}
	insert+=" $line";
    done < "${1:-/dev/stdin}"

    if (( $noop )); then
	echo "echo $(prefix.sp; echo 'INSERT {'$insert'} WHERE {}') | _http PATCH $(url) Content-Type:application/sparql-update"
    else
	(prefix.sp; echo 'INSERT {'$insert'} WHERE {}') |
	    _http PATCH $(url) Content-Type:application/sparql-update
    fi
}

function ls() {
    pushd $1
    _http GET $(url)
    popd
}

function delete() {
    # Get options
    OPTS=`getopt -o f  --long force,tombstone -n 'inf4 delete' -- "$@"` 
    if [ $? != 0 ] ; then echo "Bad delete options." >&2 ; exit 1 ; fi
    eval set -- "$OPTS"
    tombstone=
    while true; do
    	case $1 in
	    -f | --force | --tombstone) tombstone=1; shift;;
	    --) shift; break;;
    	    *) break;;
    	esac
    done

    pushd $1;
    _http DELETE $(url)
    if [[ -n $tombstone ]]; then
	echo DELETE $(url)/fcr:tombstone
	_http DELETE $(url)/fcr:tombstone
    fi;
    popd $1
}

function touch() {
    # Get options
    OPTS=`getopt -o d --long cd -n 'inf4 [options] -- touch' -- "$@"` 
    if [ $? != 0 ] ; then echo "Bad touch options." >&2 ; exit 1 ; fi
    eval set -- "$OPTS"
    mime='text/turtle';
    cd=
    while true; do
    	case $1 in
	    -d | --cd ) cd=1; shift;;
	    --) shift; break;;
    	    *) break;;
    	esac
    done

    if (( $noop )) ; then
	echo "http PUT $(url) Content-Type:$mime"
    else
	if [[ -n cd ]] ; then
	    cd $1
	    _http PUT $(url) Content-Type:$mime
	else
	    pushd $1;
	    _http PUT $(url) Content-Type:$mime
	    popd
	fi
    fi
}

function mkdir() {
    # Get options
    OPTS=`getopt -o m:r:cd --long member:,resource:,collection,dir -n 'inf4 [options] -- mkdir' -- "$@"` 
    if [ $? != 0 ] ; then echo "Bad mkdir options." >&2 ; exit 1 ; fi
    eval set -- "$OPTS"
    a=
    member_relation=
    member_resource='..'
    while true; do
    	case $1 in
	    -d | --dir ) member_relation='hasFile'; shift;;
	    -c | --collection ) member_relation='hasCollection'; shift;;
	    -m | --member) member_relation=$2; shift 2;;
	    -r | --resource) member_resource=$2; shift 2;;
	    --) shift; break;;
    	    *) break;;
    	esac
    done

    pushd $1;
    mime='text/turtle';
    if [[ -n $member_relation ]] ; then
       a=$(ldp_direct $member_relation $member_resource)
    fi
       
    if (( $noop )) ; then
	echo "http PUT $(url) Content-Type:$mime <<< '$(prefix; echo $input )'"
    else
	(prefix; echo $input ) | _http PUT $(url) Content-Type:$mime
    fi
    popd $1;
}


function put() {
    # Get options
    OPTS=`getopt -o s:m:a:d --long sidecar:,mime-type:,member:,resource:,a:,dir -n 'inf4 put' -- "$@"` 
    if [ $? != 0 ] ; then echo "Bad put options." >&2 ; exit 1 ; fi
    eval set -- "$OPTS"
    sidecar=
    mime=
    member_relation=
    member_resource='..'
    a=
    input=
    while true; do
    	case $1 in
	    -s | --sidecar)
		if [[ "$2" == "-" ]]; then
		    sidecar=/dev/stdin
		else
		    sidecar=$2;
		fi;
		shift 2;
		;;
	    -m | --mime-type) mime=$2; shift 2;;
	    -d | --dir) pcdm="dir"; shift 1 ;;
	    -o | --object) pcdm="object"; shift 1;;
	    -a | --a) a="<> a $2 ."; shift 2;;
	    --member) member_relation=$2; shift 2;;
	    --resource) member_resource=$2; shift 2;;
	    --) shift; break;;
    	    *) break;;
    	esac
    done
        
    #    file=0
    # This is not fully baked
    case $pcdm in
	object)
	    a='ldp:Resource, pcdm:Object .'
	    ;;
	collection)
	    mime='text/turtle';
	    if [[ -z $member_relation ]]; then
		member_relation='hasMember';
	    fi
	    a=$(ldp_direct $member_relation $member_resource)
	    ;;
	dir)
	    mime='text/turtle';
	    if [[ -z $member_relation ]]; then
		member_relation='hasFile';
	    fi
	    a=$(ldp_direct $member_relation $member_resource)
	    ;;
    esac

    # Check for binary file input mime-type
    if [[ -z $mime && -f $1 ]]; then
	mime=`file --mime-type -b $1`;
    fi;

    # If we've added a PCDM, type, then add to input, and also add file, or stdin
    if [[ -n $a ]]; then
	mime='text/turtle'
	input="$a";
	# READ IN File or STDIN
	while IFS= read -r line || [[ -n "$line" ]]; do
	    input+=" $line";
	done < "${1:-/dev/stdin}"
    fi;

    if (( $noop )) ; then
	if [[ -z $a ]] ; then
	    echo "http PUT $(url) Content-Type:$mime < $1"
	else
	    echo "http PUT $(url) Content-Type:$mime <<< '$(prefix; echo $input )'"
	fi
    else
	if [[ -z $a ]] ; then
	    _http PUT $(url) Content-Type:$mime < $1
	else
	    (prefix; echo $input ) | _http PUT $(url) Content-Type:$mime
	fi
    fi
    # Post process
    if [[ -z $a ]] ; then
	if (( $noop )); then
	    echo 'pushd fcr:metadata'
	    echo "patch  <<< '<> a pcdm:File .'"
	    if [[ ! -z $sidecar ]] ; then
		echo "patch $sidecar"
	    fi
	    echo "popd"		
	else
	    pushd fcr:metadata
	    patch  <<< '<> a pcdm:File .'
	    if [[ ! -z $sidecar ]] ; then
		patch $sidecar
	    fi
	    popd
	fi
    else
	if [[ ! -z $sidecar ]] ; then
	    if [[ $mime = 'text/turtle' ]]; then
		patch $sidecar
	    else
		pushd fcr:metadata
		patch $sidecar
		popd
	    fi
	fi
    fi
}

function headers() {
    shopt -s extglob # Required to trim whitespace; see below
    while IFS=':' read key value; do
	value=${value##+([[:space:]])}; value=${value%%+([[:space:]])}
	case "$key" in
            HTTP*) read PROTO STATUS MSG <<< "$key{$value:+:$value}"
		   header[$key]=declare -A 
                   ;;
	    *) header[$key]=$value;
		;;

	esac 
    done <<< "$1"
}

: <<=cut
=pod

=head1 AUTHOR

Quinn Hart <qjhart@ucdavis.edu>

=cut


#MAIN
declare -A PREFIX;

main.options $@

eval set -- "$CMD"		# sets the CMD after initial parse

if (( $INTERACTIVE )) ; then
    while read -p `pwd`'> ' cmd a b c; do
	main.cmd $cmd $a $b $c
    done
else
    main.cmd $@
fi

# if -d in parameters, pop of that item
if (( $PUSHED )); then
    popd > /dev/null
fi;

# if not --no-rc, then write config
if (( $RC )); then
    config.writerc;
fi

exit 0;

