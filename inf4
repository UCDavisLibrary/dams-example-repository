#! /bin/bash

# program at end of file. search #MAIN

function log() {
  local level=0;
  if [[ $1 = -v* ]]; then
    let level=${#1}-1;
    shift
  fi
  if [[ $level -le ${INF4[verbose]} ]]; then
    (>&2 echo $@)
  fi
}

function err() {
  local n=1;
  if [[ $1 = '--quiet' ]] ; then
    n=$2;
  else
    n=$1
    shift
    (>&2 echo err: $@)
  fi
  exit $n;
}

function _http () {
  local stdinp=
  if [[ $1 == '-n' ]]; then
    if [[ ! -t 0 ]]; then
      IFS='' read -r -d '' stdinp;
      log "http --print=${INF4[http_print]} $@ <<<'$stdinp'"
    else
      log "http --print=${INF4[http_print]} $@"
    fi
  else
    log http $@
    http $@
  fi
}


: <<=cut
=pod
=head1  NAME
  inf4 - Communicate with a Fedora 4 server
=head1 USAGE
  inf4 [-b|--base=I<base>] [-x|--prefix=I<prefix>] [-r|--no-rc] \
	[-n|--dry-run] [-d|--dir] [-i|--interactive] [-p|--print] \
	I<cmd> [cmd-options]
	where <cmd> = config|patch|put|GET|HEAD|OPTIONS|url
=cut

: <<=cut
=pod
=head1 OPTIONS
=over 4
=item B<-b|--base=I<INF4_BASE>>
 set the Fedora4 URL
=item B<-x |--prefix=> I<prefix>>
Add a new prefix for ttl, using prefix:url  format
=item B<-r|--no-rc>
Do not read from or write to rc file.
=item B<-n|--dry-run>
Show what you would do do not really do it
=item B<-d|--dir>
Set URL (wrt. INF4_BASE) for this operation only
=item B<-i|--interactive>
Use interactive mode
=item B<-p|--print>
Adjust httpie --print= argument
=back
=cut

function main.cmd () {
    cmd=$1
    shift;

    case $cmd in
      file.path | file.ignore)
        $cmd $@;
        ;;
      item.fetch )
        $cmd $@;
        ;;
      file.metadata | file.is_metadata | file.metadata_file ) # Metadata Commands
        $cmd $@;
        ;;
      add | put ) # Update Commands
        $cmd $@;
        ;;
#	    cd | pwd | pushd | popd ) # Directory Commands
#        $cmd $@;
#        ;;
      put | config | login | patch)
	      $cmd $@;
	      ;;
#      GET | HEAD | OPTIONS | url )	# http requests
#	      $cmd $@;
#	      ;;

      *)
	      echo  "$cmd not found";
	      ;;
    esac
}

: <<=cut
=pod
=head2 metadata
=head3 USAGE
inf4 [inf4options] metadata --auto --mime-type=[mime-type] file
=head4
displays the metadata associated with any file.
=head4 init
Writes or overwrites the configuration file <./.inf4rc>. And options passed to the
inf4 command are included, For example
inf4 --base=https://foo.com/fcrepo/rest/bar \
     --prefix=baz:https://baz.org/schema config
Will write a new configuration file with the base and prefix set.
=cut
function file.metadata() {
  local opts=`getopt -o @:atM:u --long file:,auto:,type:,no-metadata,mime-type:,update -n 'inf4 put' -- "$@"`
  if [ $? != 0 ] ; then err 1 "Bad inf4 file.metadata options."; fi
  eval set -- "$opts"
  metadata_opts $@
}

function metadata_opts() {
  local metadata=
  local no_metadata=
  local mime=
  local name=
  declare -A types;
  local file=
  local update=

  while true; do
    case $1 in
      -@ | --file ) # Used for mime-types
        file=$2;
        shift 2;;
      -a | --auto)
        auto=1;
        shift;
        ;;
	    -M | --no-metadata)
        no_metadata=1;
        shift;
		    ;;
	    -m | --mime-type)
        mime=$2; shift 2;;
      -t | --type)
        types+=($2);
        shift 2;;
      -u | --update)
        update=1;
        shift;;
	  	--) shift; break;;
    	*) break;;
    esac
  done

#  declare -a types=('ldp:NonRDFSource');

  metadata=$(file.metadata_file --quiet --exists $file)
  if [[ -n $metadata ]]; then
    cat $metadata;
    exit 0
  fi

  local basename=$(basename $file);

  if [[ -z $mime ]]; then
    if [[ $file =~ .ttl$ ]] ; then
      mime=text/turtle
    elif [[ -n $file ]]; then
		  mime=$(file --mime-type -b $file);
	  fi;
  fi

  if [[ $mime =~ ^image/.* ]]; then
    types+=('schema:ImageObject');
  fi

  local typestr=$(printf "%s," ${types[@]})

  if [[ -z $extra ]]; then
      read -r -d '' metadata <<AUTO;
@prefix ldp:    <http://www.w3.org/ns/ldp#> .
@prefix schema: <http://schema.org/> .
@prefix ebucore: <http://www.ebu.ch/metadata/ontologies/ebucore/ebucore#> .
<> a ${typestr%,};
  ebucore:filename "$basename" .
AUTO
    else
      read -r -d '' metadata <<AUTO;
@prefix ldp:    <http://www.w3.org/ns/ldp#> .
@prefix schema: <http://schema.org/> .
@prefix ebucare: <http://www.ebu.ch/metadata/ontologies/ebucore/ebucore#> .
<> a ${typestr%,};
   ${extra}
  ebucore:filename "$basename" .
AUTO
  fi
  echo "$metadata"
}

function file.ignore() {
  local path=$(realpath $1)
  local home=${INF4[home]}
  for i in "${!IGNORE[@]}"; do
    if [[ $path = $home/$i ]]; then
      log -vvv file.ignore "$1=$i"
      exec true
    fi
  done
  # have to check dirs as well
  path=$(dirname $path)
  while [[ $path > $home && $path != '/' ]]; do
    for i in "${!IGNORE[@]}"; do
      if [[ $1 = $i ]]; then
        log -vvv IGNORE "$1='$i'"
        exec true
      fi
    done
    path=$(dirname $path)
  done
  exec false
}

: <<=cut
=pod
=head2 file.is_metadata
=head3 USAGE
inf4 [inf4options] file.is_metadata file
=head4

Returns true if the passed file is a metadata file, false if not. The file
undergoes two tests. First it is validated as a metadata file type, based on the
metadata file patterns (metadata.file in YML file). If the file matches the pattern, then the
associated file is checked for existance. If the file exists, then we assume the
file is a metadata file associated with the appropriate file or directory.
Can be used like C<if (inf4 file.is_metadata foo.png.ttl); then echo metadata; fi>.

=cut
function file.is_metadata() {
  local file_pattern=${INF4[metadata_pattern]}
  if [[ $1 =~ ${file_pattern} && -f ${BASH_REMATCH[1]} ]]; then
    exit 0;
  else
    exit 1;
}

function file.metadata_file() {
    local opts=`getopt -o qx --long quiet,exists -n 'file.metadata_file' -- "$@"`
    if [[ $? != 0 ]] ; then return ; fi

    eval set -- "$opts"

    local mf=${INF4[metadata_file]};
    local ttl;
    local exists=;
    local quiet=

    while true; do
	    case $1 in
	      -x | --exists) exists=1;  shift;;
        -q | --quiet ) quiet='--quiet'; shift;;
	      -- ) shift; break;;
	      *) shift; break;
      esac
    done

    # First check if it's a metadata file then exit 1
    if [[ ! -d $1 && ! -f $1 ]]; then
      err $quiet 1 "$1 not found"
    fi

    if (file.ignore $1); then
      err $quiet "$1 file.ignore"
    fi
    if (file.is_metadata $1) ; then
      err $quiet "$1 file.is_metadata"
    fi

    if [[ -f $1 || -d $1 ]] ; then
      ttl=${mf//FILE/$1}
      if [[ -n $exists && ! -f $ttl ]]; then
        err $quiet "$ttl not found"
      fi
    fi;
    echo $ttl
    exit 0;
}

: <<=cut
=pod
=head2 file.path
=head3 USAGE
inf4 file.path --full <filepath>
=head4
Returns the LDP path location for the file.  The default is to simply remove
the suffix from the basename of a file.  With full however, the suffix is retained.
=cut
function file.path() {
  local opts=`getopt -o f --long full -n 'file.path' -- "$@"`
  if [[ $? != 0 ]] ; then return ; fi

  eval set -- "$opts"

  local full=

  while true; do
	  case $1 in
	    -f | --full) full=1;  shift;;
	    -- ) shift; break;;
	    *) shift; break;
    esac
  done

  if (file.ignore $1); then
    err 1 "$1 file.ignore"
  elif (file.is_metadata $1); then
    err 1 "$1 file.is_metadata"
  fi

#  local filename=$(basename $1)
#  local dirname=$(dirname $(realpath --relative-to=${INF4[home]} $1))
#  echo $dirname/$filename;

  local path=$(realpath --relative-to=${INF4[home]} $1)
  echo $path
}

ldp_path() {
  local filename
  local dirname
  if [[ $1 = '--full' ]] ; then
    shift;
    filename=$(basename $1)
    filename=${filename//./_}
  else
    filename=$(basename $1)
    filename=${filename//.*/}
  fi
  dirname=$(dirname $(realpath --relative-to=${INF4[home]} $1))
  echo $dirname/$filename
}

: <<=cut
=pod
=head2 file
=head3 USAGE
inf4 item fetch --etag --metadata --binary <item>
=head4
Add a file or directory to an LDP.
=cut
function item.fetch() {
  local opts=`getopt -o meb --long metadata,binary,etag -n 'inf4 item.fetch' -- "$@"`
  if [ $? != 0 ] ; then err 1 "Bad inf4 item.fetch options."; fi
  eval set -- "$opts"

  local metadata=
  local etag=
  local binary=
  local check=

  while true; do
    case $1 in
      -m | --metadata ) # Used for mime-types
        metadata=1;
        shift;;
      -e | --etag)
        etag=1;
        shift;
        ;;
	    -b | --binary)
        binary=;
        shift;
		    ;;
	  	--) shift; break;;
    	*) break;;
    esac
  done
  local head
  local file=$1
  local metadata_file=

  local path=$(ldp.path $file)
  head=$(_http --print=h HEAD $(url $path))
  eval $(parse_headers "$head")

#  if [[ -n $etag ]]; then
#    if [[ -n $check ]]; then
  if [[ -f $file ]]; then
    echo ${headers[etag]} >> $file.ldp.etag
    # Now get metadata header
    head=$(_http --print=h HEAD $(url $path)/fcr:metadata)
    eval $(parse_headers "$head")
    echo ${headers[etag]} >> $file.ldp.ttl.etag
    _http GET $(url $path)/fcr:metadata prefer:return=minimal Accept:text/turtle > $file.ldp.ttl
  elif [[ -d $file ]]; then
    echo ${headers[etag]} >> $file/ldp.etag
    head=$(_http --print=h HEAD $(url $path)/fcr:metadata)
    eval $(parse_headers "$head")
    echo ${headers[etag]} >> $file/ldp.ttl.etag
    _http GET $(url $path)/fcr:metadata prefer:return=minimal Accept:text/turtle > $file/ldp.ttl
  else
    err 1 "item.fetch $file not actionable"
  fi

}



: <<=cut
=pod
=head2 put
=head3 USAGE
inf4 [inf4options] put --auto --mime-type=I<mime> --extra=I<extra> file
=head4
Add a file or directory to an LDP.
=cut
function url() {
  echo ${INF4[host]}/$(realpath -m /${INF4[base]}/$1)
}

function put() {
  local opts=`getopt -o @:atM:u --long file:,auto:,type:,no-metadata,mime-type:,update -n 'inf4 put' -- "$@"`
  if [ $? != 0 ] ; then err 1 "Bad inf4 put options."; fi
  eval set -- "$opts"

  local metadata=
  local no_metadata=
  local mime=
  local name=
  declare -A types;
  local file=
  local update=

  while true; do
    case $1 in
      -@ | --file )
        file=$2;
        shift 2;;
      -a | --auto )
        auto=1;
        shift;
        ;;
	    -M | --no-metadata )
        no_metadata=1;
        shift;
		    ;;
	    -m | --mime-type )
        mime=$2; shift 2;;
      -t | --type)
        types+=($2);
        shift 2;;
      -u | --update )
        update=1;
        shift;;
	  	--) shift; break;;
    	*) break;;
    esac
  done

  if [[ -f $file ]]; then
    if [[ -z $mime ]]; then
      if [[ $file =~ .ttl$ ]] ; then
        mime=text/turtle
      else
		    mime=$(file --mime-type -b $file);
	    fi;
    fi;
	  _http -n PUT $(url $1) Content-Type:$mime @$file
  elif [[ -z $update && -d $file ]] ; then
    _http -n PUT $(url $1)
  fi

  # Now add metadata
  if [[ -z $no_metadata ]]; then
    eval set -- "$opts"
    metadata=$(metadata_opts $@ )
    _http -n  PUT prefer:return=minimal Content-Type:text/turtle $(url $file)/fcr:metadata <<<$metadata
  fi
}

: <<=cut
=pod
=head2 add
=head3 USAGE
inf4 [inf4options] add --auto directory
=head4
Add items to the collection. This will add all files from an item into the system.
=cut
function add() {
  local opts=`getopt -o a --long auto -n 'inf4 add' -- "$@"`
  if [[ $? != 0 ]] ; then return ; fi
  eval set -- "$opts"

  local metadata;
  local d;
  local f;
  local i;
  declare -a types;
  local auto=
  declare -A file_for  # [file_for] => filename

    while true; do
	    case $1 in
        -a | --auto ) auto=--auto; shift;;
	      -- ) shift; break;;
	      *) shift; break;
      esac
    done

    for i in $@; do
      if ! (file.ignore $i) ; then
        # Save files, check ldp.path
        if ! ( file.is_metadata $i) && [[ -f $i ]]; then
          local fn=$(ldp.path $i);
          #log "F->FN $i->$fn"
          if [[ ${file_for[$fn]} ]] ; then
            # we have name collision, redo
            local p=${file_for[$fn]}
            local p_fn=$(ldp.path --full $p)
            if [[ ${file_for[$p_fn]} ]]; then
              err 1 "ldp object collision $p_fn: $p and ${file_for[$p_fn]}"
            else
              unset file_for[$fn]
              file_for[$p_fn]=$p;
            fi
            fn=$(ldp.path --full $i)
            if [[ ${file_for[$fn]} ]]; then
              err 1 "ldp object collision $fn: $i and ${file_for[$fn]}"
            fi
          else
            file_for[$fn]=$i;
          fi
        elif [[ -d $i ]]; then
          i=${i%/}
          fn=$(ldp.path $i)
          if [[ ${file_for[$fn]} ]]; then
            err 1 "ldp object collision $fn: $i and ${file_for[$fn]}"
          fi
  #        file_for[$fn]=$i;
          put --no-metadata --file=$i $fn
          add $i/*;
          put --update $auto --file=$i $fn
        else
          #log "skipping $i"
          true;
        fi
      fi
    done
    # Now add each file
    for fn in ${!file_for[@]}; do
      put $auto --file=${file_for[$fn]} $fn
    done
}

urlencode() {
    # urlencode <string>
    old_lc_collate=$LC_COLLATE
    LC_COLLATE=C

    local length="${#1}"
    for (( i = 0; i < length; i++ )); do
        local c="${1:i:1}"
        case $c in
            [a-zA-Z0-9.~_-]) printf "$c" ;;
            *) printf '%%%02X' "'$c" ;;
        esac
    done

    LC_COLLATE=$old_lc_collate
}

: <<=cut
=pod
=head2 login
=head3 USAGE
inf4 [inf4options] login --headless
=head4
Allows users to login to the system.  The

=cut
function login() {
  local opts
  local token

  local prompt

  read -r -d '' prompt <<PROMPT;
Visit this URL on any device to log in, then paste token below.
${INF4[host]}/auth/cas/login?cliRedirectUrl=$(urlencode ${INF4[host]}/auth/login-shell)&provideJwt=true&force=true

Token:
PROMPT

  read -p "$prompt" -r token;

  http --print=${INF4[http_print]} --session=${INF4[http_session]} ${INF4[host]}/${INF4[base]} Authorization:"Bearer $token"
}

: <<=cut
=pod
=head2 config
=head3 USAGE
inf4 [inf4options] config
=head4
displays the configuration
=cut
function config() {
  declare -p INF4
  declare -p IGNORE
}

function _home() {
  local pwd=${PWD}
  local home=${HOME}
  while [[ $pwd != $home && $pwd != '/' ]]; do
    if [[ -d ${pwd}/.inf4 ]]; then
      inf4=$pwd;
      break;
    fi
    pwd=$(dirname $pwd);
  done
  if [[ -z $inf4 ]]; then
    echo "fatal: Not a inf4 repository (or any of the parent directories): .inf4" 1>&2
    exit 128;
  fi;
  INF4[home]=${inf4};
}

function _config_file() {
  local pwd=${PWD}/
  local home=${INF4[home]}
  local file;
  until [[ $pwd < $home ]]; do
    if [[ -f ${pwd}$1 ]]; then
      file=${pwd}$1;
      break;
    fi
    pwd=$(dirname $pwd);
  done
  echo $file
}

function _read_attributes() {
  local attr=$(_config_file .inf4attributes)
  local pat
  local val
  if [[ -n $attr ]]; then
    while read -r pat val; do
      if [[ -n $pat && $pat != \#* ]]; then
        ATTR[$pat]="$val"
      fi
    done < $attr
  fi
}

function _read_ignore() {
  local attr
  local pat
  local dir
  for attr in $(_config_file .inf4ignore); do
    dir=$(dirname $attr);
    local a=${attr#${INF4[home]}/}
    if [[ -n $attr ]]; then
      while IFS='' read  pat; do
        if [[ -n $pat && $pat != \#* ]]; then
          pat=$(realpath $dir/./"$pat")
          pat=${pat#${INF4[home]}/}
          IGNORE[$pat]=$a
        fi
      done < $attr
    fi
  done
}

function parse_headers() {
shopt -s extglob # Required to trim whitespace; see below
declare -A headers
while IFS=':' read key value; do
    # trim whitespace in "value"
    value=${value##+([[:space:]])}; value=${value%%+([[:space:]])}
    headers[$key]=$value;
done <<< "$1"
declare -p headers
}

function parse_yaml() {
  local prefix=$2
  local s='[[:space:]]*' w='[a-zA-Z0-9_]*' fs=$(echo @|tr @ '\034')
  sed -ne "s|^\($s\)\($w\)$s:$s\"\(.*\)\"$s\$|\1$fs\2$fs\3|p" \
      -e "s|^\($s\)\($w\)$s:$s\(.*\)$s\$|\1$fs\2$fs\3|p"  $1 |
    awk -F$fs '{
      indent = length($1)/2;
      vname[indent] = $2;
      for (i in vname) {if (i > indent) {delete vname[i]}}
      if (length($3) > 0) {
         vn=""; for (i=0; i<indent; i++) {vn=(vn)(vname[i])("_")}
         printf("INF4[%s%s]=\"%s\"\n", vn, $2, $3);
      }
   }'
}

: <<=cut
=pod
=head1 AUTHOR
Quinn Hart <qjhart@ucdavis.edu>
=cut

#MAIN
declare -A INF4;
declare -A ATTR;
declare -A IGNORE;
declare -A OPTS;

_home # Verify we are

# Read the configuration file
config=${INF4[home]}/.inf4/config.yml
if [[ -f $config ]]; then
  eval $(parse_yaml $config)
fi

_read_attributes
_read_ignore

while true; do
	case $1 in
	  -*) OPTS=($1); shift ;;
	  -- ) shift; break;;
	  *) break;
	esac
done

function init() {
local opts=`getopt -o h:np: --long base:,dry-run,print: -n 'inf4' -- "$@"`

if [ $? != 0 ] ; then echo "Bad Command Options." >&2 ; exit 1 ; fi

eval set -- "$opts"

while true; do
	case $1 in
	  -n | --dry-run) INF4[noop]=1; shift ;;
	  -p | --print) INF4[print]=$2; shift 2;;
	  -- ) shift; break;;
	  *) break;
	esac
done
}
main.cmd "$@"

exit 0;

# Not added yet
function patchin() {
    OPTS=`getopt -o c:i:d: --long collection:,path:,data: -n 'fin_patchin' -- "$@"`
    # Exit if
    if [[ $? != 0 ]] ; then return ; fi

    local col=
    local path
    local data

    eval set -- "$OPTS"

    while true; do
	    case $1 in
	      -c | --collection) col=$2;  shift 2;;
	      -p | --path) path=$2;  shift 2;;
	      -d | --data) data=$2;  shift 2;;
	      -- ) shift; break;;
	      *) shift; break;
      esac
    done

    if [[ -n $col ]]; then
      path=/collection/$col/$path;
    fi
    echo fin http patch --data-string "$data" -P h "$path/fcr:metadata"
}
