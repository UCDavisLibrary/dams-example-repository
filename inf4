#! /bin/bash

# program at end of file. search #MAIN

function log() {
  local level=0;
  if [[ $1 = -v* ]]; then
    let level=${#1}-1;
  fi
  shift
  if [[ $level <= $INF4[verbose] ]]; then
    (>&2 echo LOG: $@)
  fi
}

function err() {
  local n;
  if [[ $1 = '--quiet' ]] ; then
    n=$2;
  else
    n=$1
    shift
    (>&2 echo err: $@)
  fi
  exit $n;
}

function _http () {
  local stdinp=
  if [[ ! -t 0 ]]; then
    IFS='' read -r -d '' stdinp;
    log "http --print=${INF4[http_print]} $@ <<<'$stdinp'"
  else
    log "http --print=${INF4[http_print]} $@"
  fi
}


: <<=cut
=pod
=head1  NAME
  inf4 - Communicate with a Fedora 4 server
=head1 USAGE
  inf4 [-b|--base=I<base>] [-x|--prefix=I<prefix>] [-r|--no-rc] \
	[-n|--dry-run] [-d|--dir] [-i|--interactive] [-p|--print] \
	I<cmd> [cmd-options]
	where <cmd> = config|patch|put|GET|HEAD|OPTIONS|url
=cut

: <<=cut
=pod
=head1 OPTIONS
=over 4
=item B<-b|--base=I<INF4_BASE>>
 set the Fedora4 URL
=item B<-x |--prefix=> I<prefix>>
Add a new prefix for ttl, using prefix:url  format
=item B<-r|--no-rc>
Do not read from or write to rc file.
=item B<-n|--dry-run>
Show what you would do do not really do it
=item B<-d|--dir>
Set URL (wrt. INF4_BASE) for this operation only
=item B<-i|--interactive>
Use interactive mode
=item B<-p|--print>
Adjust httpie --print= argument
=back
=cut

function main.cmd () {
    cmd=$1
    shift;

    case $cmd in
      util.ignore )
        $cmd $@;
        ;;
      metadata | is_metadata_file | metadata_file ) # Metadata Commands
        $cmd $@;
        ;;
      add | put ) # Update Commands
        $cmd $@;
        ;;
#	    cd | pwd | pushd | popd ) # Directory Commands
#        $cmd $@;
#        ;;
      put | config | login | patch)
	      $cmd $@;
	      ;;
#      GET | HEAD | OPTIONS | url )	# http requests
#	      $cmd $@;
#	      ;;

      *)
	      echo  "$cmd not found";
	      ;;
    esac
}

: <<=cut
=pod
=head1 CMD
=cut
function main.options() {
  local opts=`getopt -o h:np: --long base:,dry-run,print: -n 'inf4' -- "$@"`

  if [ $? != 0 ] ; then echo "Bad Command Options." >&2 ; exit 1 ; fi

  eval set -- "$opts"

  while true; do
	case $1 in
	    -n | --dry-run) INF4[noop]=1; shift ;;
	    -p | --print) INF4[print]=$2; shift 2;;
	    -- ) shift; break;;
	    *) break;
	esac
  done
}

: <<=cut
=pod
=head2 metadata
=head3 USAGE
inf4 [inf4options] metadata --auto --mime-type=[mime-type] file
=head4
displays the metadata associated with any file.
=head4 init
Writes or overwrites the configuration file <./.inf4rc>. And options passed to the
inf4 command are included, For example
inf4 --base=https://foo.com/fcrepo/rest/bar \
     --prefix=baz:https://baz.org/schema config
Will write a new configuration file with the base and prefix set.
=cut
function metadata() {
  local opts=`getopt -o @:atM:u --long file:,auto:,type:,no-metadata,mime-type:,update -n 'inf4 put' -- "$@"`
  if [ $? != 0 ] ; then err 1 "Bad inf4 metadata options."; fi
  eval set -- "$opts"

  local metadata=
  local no_metadata=
  local mime=
  local name=
  declare -A types;
  local file=
  local update=

  while true; do
    case $1 in
      -@ | --file ) # Used for mime-types
        file=$2;
        shift 2;;
      -a | --auto)
        auto=1;
        shift;
        ;;
	    -M | --no-metadata)
        no_metadata=1;
        shift;
		    ;;
	    -m | --mime-type)
        mime=$2; shift 2;;
      -t | --type)
        types+=($2);
        shift 2;;
      -u | --update)
        update=1;
        shift;;
	  	--) shift; break;;
    	*) break;;
    esac
  done

#  declare -a types=('ldp:NonRDFSource');

  metadata=$(metadata_file --quiet --exists $file)
  if [[ -n $metadata ]]; then
    cat $metadata;
    exit 0
  fi

  local basename=$(basename $1);

  if [[ -z $mime ]]; then
    if [[ $file =~ .ttl$ ]] ; then
      mime=text/turtle
    elif [[ -n $file ]]; then
		  mime=$(file --mime-type -b $file);
	  fi;
  fi

  if [[ $mime =~ ^image/.* ]]; then
    types+=('schema:ImageObject');
  fi

  local typestr=$(printf "%s," ${types[@]})

  if [[ -z $extra ]]; then
      read -r -d '' metadata <<AUTO;
@prefix ldp:    <http://www.w3.org/ns/ldp#> .
@prefix schema: <http://schema.org/> .
@prefix ebucare: <http://www.ebu.ch/metadata/ontologies/ebucore/ebucore#> .
<> a ${typestr%,};
  ebucore:filename "$basename" .
AUTO
    else
      read -r -d '' metadata <<AUTO;
@prefix ldp:    <http://www.w3.org/ns/ldp#> .
@prefix schema: <http://schema.org/> .
@prefix ebucare: <http://www.ebu.ch/metadata/ontologies/ebucore/ebucore#> .
<> a ${typestr%,};
   ${extra}
  ebucore:filename "$basename" .
AUTO
  fi
  echo "$metadata"
}

function util.ignore() {
  local path=$(realpath $1)
  local home=${INF4[home]}
  for i in "${!IGNORE[@]}"; do
    if [[ $path = $home/$i ]]; then
      log IGNORE "$1='$i'"
      exec true
    fi
  done
  # have to check dirs as well
  path=$(dirname $path)
  while [[ $path > $home && $path != '/' ]]; do
    log $path
    for i in "${!IGNORE[@]}"; do
      if [[ $1 = $i ]]; then
        log IGNORE "$1='$i'"
        exec true
      fi
    done
    path=$(dirname $path)
  done
  exec false
}

: <<=cut
=pod
=head2 is_metadata_file
=head3 USAGE
inf4 [inf4options] is_metadata_file file
=head4

Returns true if the passed file is a metadata file, false if not. The file
undergoes two tests. First it is validated as a metadata file type, based on the
FILE and DIR metadata file patterns. If the file matches the pattern, then the
associated file is checked for existance. If the file exists, then we assume the
file is a metadata file associated with the appropriate file or directory.
Can be used like C<if (inf4 is_metadata foo.png.ttl); then echo metadata; fi>.

=cut
function is_metadata_file() {
  local file_pattern='^(.*)\.ttl$'
  local dir_metadata='^index.ttl$'
  if [[ $(basename $1) =~ ${dir_metadata} && -d $(dirname $1) ]]; then
    exit 0;
  elif [[ $1 =~ ${file_pattern} ]]; then
    if [[ -f ${BASH_REMATCH[1]} ]]; then
      exit 0;
    fi
  else
    exit 1;
  fi
}

function metadata_file() {
    local opts=`getopt -o qx --long quiet,exists -n 'metadata_file' -- "$@"`
    if [[ $? != 0 ]] ; then return ; fi

    eval set -- "$opts"

    local file_pattern='FILE.ttl';
    local dir_pattern='DIR/index.ttl';
    local ttl;
    local exists=;
    local quiet=

    while true; do
	    case $1 in
	      -x | --exists) exists=1;  shift;;
        -q | --quiet ) quiet='--quiet'; shift;;
	      -- ) shift; break;;
	      *) shift; break;
      esac
    done

    # First check if it's a metadata file then exit 1
    if [[ ! -d $1 && ! -f $1 ]]; then
      err $quiet 1 "$1 not found"
    fi

    if (is_metadata_file $1) ; then
      err $quiet 1 "$1 is a metadata file"
    fi

    if [[ -f $1 ]] ; then
      ttl=${file_pattern//FILE/$1}
      if [[ -n $exists && ! -f $ttl ]]; then
        err 1 "$ttl not found"
      fi
    elif [[ -d $1 ]] ; then
      ttl=${dir_pattern//DIR/$1}
      if [[ -n $exists && ! -f $ttl ]]; then
        err $quiet 1 "$ttl not found"
      fi
    fi;
    echo $ttl
    exit 0;
}

ldp_filename() {
  local filename
  local dirname
  if [[ $1 = '--full' ]] ; then
    dirname=$(dirname $2)
    filename=$(basename $2)
    filename=${filename//./_}
  else
    dirname=$(dirname $1)
    filename=$(basename $1)
    filename=${filename//.*/}
  fi
  echo $dirname/$filename
}


: <<=cut
=pod
=head2 put
=head3 USAGE
inf4 [inf4options] put --auto --mime-type=I<mime> --extra=I<extra> file
=head4
Add a file or directory to an LDP.
=cut
function put() {
  # Get options
  local opts=`getopt -o @:atM:u --long file:,auto:,type:,no-metadata,mime-type:,update -n 'inf4 put' -- "$@"`
  if [ $? != 0 ] ; then err 1 "Bad inf4 put options."; fi
  eval set -- "$opts"

  local metadata=
  local no_metadata=
  local mime=
  local name=
  declare -A types;
  local file=
  local update=

  while true; do
    case $1 in
      -@ | --file )
        file=$2;
        shift 2;;
      -a | --auto )
        auto=1;
        shift;
        ;;
	    -M | --no-metadata )
        no_metadata=1;
        shift;
		    ;;
	    -m | --mime-type )
        mime=$2; shift 2;;
      -t | --type)
        types+=($2);
        shift 2;;
      -u | --update )
        update=1;
        shift;;
	  	--) shift; break;;
    	*) break;;
    esac
  done

  if [[ -f $file ]]; then
    if [[ -z $mime ]]; then
      if [[ $file =~ .ttl$ ]] ; then
        mime=text/turtle
      else
		    mime=$(file --mime-type -b $file);
	    fi;
    fi;
	  $(_http PUT $1 Content-Type:$mime @$file)
  elif [[ -z $update && -d $file ]] ; then
    $(_http PUT $1)
  fi

  # Now add metadata
  if [[ -z $no_metadata ]]; then
    metadata=$(metadata $opts )
    $(_http  PUT prefer:return=minimal Content-Type:text/turtle $1/fcr:metadata <<<$metadata)
  fi
}

: <<=cut
=pod
=head2 add
=head3 USAGE
inf4 [inf4options] add --auto directory
=head4
Add items to the collection. This will add all files from an item into the system.
=cut
function add() {
  local opts=`getopt -o a --long auto -n 'inf4 add' -- "$@"`
  if [[ $? != 0 ]] ; then return ; fi
  eval set -- "$opts"

  local metadata;
  local d;
  local f;
  declare -a types;
  local auto=
  declare -A file_for  # [file_for] => filename

    while true; do
	    case $1 in
        -a | --auto ) auto=--auto; shift;;
	      -- ) shift; break;;
	      *) shift; break;
      esac
    done

    for i in $@; do
      if ! (util.ignore $i) ; then
        # Save files, check ldp_filename
        if ! ( is_metadata_file $i) && [[ -f $i ]]; then
          local fn=$(ldp_filename $i);
          #log "F->FN $i->$fn"
          if [[ ${file_for[$fn]} ]] ; then
            log COLL "file_for[$fn] is ${file_for[$fn]}"
            # we have name collision, redo
            local p=${file_for[$fn]}
            local p_fn=$(ldp_filename --full $p)
            if [[ ${file_for[$p_fn]} ]]; then
              err 1 "ldp object collision $p_fn: $p and ${file_for[$p_fn]}"
            else
              unset file_for[$fn]
              file_for[$p_fn]=$p;
            fi
            fn=$(ldp_filename --full $i)
            if [[ ${file_for[$fn]} ]]; then
              err 1 "ldp object collision $fn: $i and ${file_for[$fn]}"
            fi
          else
            file_for[$fn]=$i;
          fi
        elif [[ -d $i ]]; then
          i=${i%/}
          fn=$(ldp_filename $i)
          if [[ ${file_for[$fn]} ]]; then
            err 1 "ldp object collision $fn: $i and ${file_for[$fn]}"
          fi
  #        file_for[$fn]=$i;
          put --no-metadata --file=$i $fn
          add $i/*;
          put --update $auto --file=$i $fn
        else
          #log "skipping $i"
          true;
        fi
      fi
    done
    # Now add each file
    for fn in ${!file_for[@]}; do
      log ADDFILE $i
      put $auto --file=${file_for[$fn]} $fn
    done
}

urlencode() {
    # urlencode <string>
    old_lc_collate=$LC_COLLATE
    LC_COLLATE=C

    local length="${#1}"
    for (( i = 0; i < length; i++ )); do
        local c="${1:i:1}"
        case $c in
            [a-zA-Z0-9.~_-]) printf "$c" ;;
            *) printf '%%%02X' "'$c" ;;
        esac
    done

    LC_COLLATE=$old_lc_collate
}

: <<=cut
=pod
=head2 login
=head3 USAGE
inf4 [inf4options] login --headless
=head4
Allows users to login to the system.  The

=cut
function login() {
  local opts
  local token

  local prompt

  read -r -d '' prompt <<PROMPT;
Visit this URL on any device to log in, then paste token below.
${INF4[host]}/auth/cas/login?cliRedirectUrl=$(urlencode ${INF4[host]}/auth/login-shell)&provideJwt=true&force=true

Token:
PROMPT

  read -p "$prompt" -r token;

  http --print=${INF4[http_print]} --session=${INF4[http_session]} ${INF4[host]}/${INF4[base]} Authorization:"Bearer $token"
}

: <<=cut
=pod
=head2 config
=head3 USAGE
inf4 [inf4options] config
=head4
displays the configuration
=cut
function config() {
  declare -p INF4
  declare -p IGNORE
}

function _home() {
  local pwd=${PWD}
  local home=${HOME}
  while [[ $pwd != $home && $pwd != '/' ]]; do
    if [[ -d ${pwd}/.inf4 ]]; then
      inf4=$pwd;
      break;
    fi
    pwd=$(dirname $pwd);
  done
  if [[ -z $inf4 ]]; then
    echo "fatal: Not a inf4 repository (or any of the parent directories): .inf4" 1>&2
    exit 128;
  fi;
  INF4[home]=${inf4};
}

function _config_file() {
  local pwd=${PWD}/
  local home=${INF4[home]}
  local file;
  until [[ $pwd < $home ]]; do
    if [[ -f ${pwd}$1 ]]; then
      file=${pwd}$1;
      break;
    fi
    pwd=$(dirname $pwd);
  done
  echo $file
}

function _read_attributes() {
  local attr=$(_config_file .inf4attributes)
  local pat
  local val
  if [[ -n $attr ]]; then
    while read -r pat val; do
      if [[ -n $pat && $pat != \#* ]]; then
        ATTR[$pat]="$val"
      fi
    done < $attr
  fi
}

function _read_ignore() {
  local attr
  local pat
  local dir
  for attr in $(_config_file .inf4ignore); do
    dir=$(dirname $attr);
    local a=${attr#${INF4[home]}/}
    if [[ -n $attr ]]; then
      while IFS='' read  pat; do
        if [[ -n $pat && $pat != \#* ]]; then
          pat=$(realpath $dir/./"$pat")
          pat=${pat#${INF4[home]}/}
          IGNORE[$pat]=$a
        fi
      done < $attr
    fi
  done
}

function parse_yaml() {
  local prefix=$2
  local s='[[:space:]]*' w='[a-zA-Z0-9_]*' fs=$(echo @|tr @ '\034')
  sed -ne "s|^\($s\)\($w\)$s:$s\"\(.*\)\"$s\$|\1$fs\2$fs\3|p" \
      -e "s|^\($s\)\($w\)$s:$s\(.*\)$s\$|\1$fs\2$fs\3|p"  $1 |
    awk -F$fs '{
      indent = length($1)/2;
      vname[indent] = $2;
      for (i in vname) {if (i > indent) {delete vname[i]}}
      if (length($3) > 0) {
         vn=""; for (i=0; i<indent; i++) {vn=(vn)(vname[i])("_")}
         printf("INF4[%s%s]=\"%s\"\n", vn, $2, $3);
      }
   }'
}

: <<=cut
=pod
=head1 AUTHOR
Quinn Hart <qjhart@ucdavis.edu>
=cut

#MAIN
declare -A INF4;
declare -A ATTR;
declare -A IGNORE;

_home

# Read the configuration file
config=${INF4[home]}/.inf4/config.yml
if [[ -f $config ]]; then
  eval $(parse_yaml $config)
fi

_read_attributes
_read_ignore

while true; do
	case $1 in
	  -*) OPTS=($1); shift ;;
	  -- ) shift; break;;
	  *) break;
	esac
done

main.options $OPTS

main.cmd "$@"

exit 0;

# Not added yet
function patchin() {
    OPTS=`getopt -o c:i:d: --long collection:,path:,data: -n 'fin_patchin' -- "$@"`
    # Exit if
    if [[ $? != 0 ]] ; then return ; fi

    local col=
    local path
    local data

    eval set -- "$OPTS"

    while true; do
	    case $1 in
	      -c | --collection) col=$2;  shift 2;;
	      -p | --path) path=$2;  shift 2;;
	      -d | --data) data=$2;  shift 2;;
	      -- ) shift; break;;
	      *) shift; break;
      esac
    done

    if [[ -n $col ]]; then
      path=/collection/$col/$path;
    fi
    echo fin http patch --data-string "$data" -P h "$path/fcr:metadata"
}
